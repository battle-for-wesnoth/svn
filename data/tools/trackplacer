#!/usr/bin/env python
"""
trackplacer -- map journey track editor.

usage: trackplacesr [-vh?] [filename]

If the filename is not specified, tracplacer will pop up a file selector.

Can be started with a map image, in which case we're editing a new journey.
Can be started with a track file. A track file is a text file interpreted
line-by-line; each line is interpreted as whitespace-separated fields.
The first field of the first line must be FILE, and the second field
of that line must be valid filename.  Subsequent lines must have three
fields each: an action tag (JOURNEY, BATTLE, or REST) and two numeric
coordinate fields.

A journey is an object containing a map file name and a (possibly empty)
track. This program exists to visually edit journeys.

The -v option enables verbose logging to standard error.

The -h or -? options display this summary.
"""

import sys, exceptions, getopt

import pygtk
pygtk.require('2.0')
import gtk

import wesnoth.wmltools

# All dependencies on the shape of the data tree live here
default_map = "data/core/images/maps/wesnoth.png"
journey_icon = "data/core/images/misc/new-journey.png"
battle_icon = "data/core/images/misc/new-battle.png"
rest_icon =  "data/core/images/misc/flag-red.png"

class ReadException(exceptions.Exception):
    "Exception thrown while reading a track file."
    def __init__(self, message, filename, lineno):
        self.message = message
        self.filename = filename
        self.lineno = lineno

class JourneyTrack:
    "Represent a journey track on a map."
    def __init__(self):
        self.filename = None	# Map background of the journey
        self.track = []		# List of (action, x, y) tuples
    def write(self, fp):
        "Record a journey track."
        fp.write("FILE %s\n" % self.filename)
        for location in self.track:
            fp.write("%s %d %d\n" % location)
    def read(self, fp):
        "Initialize a journey from map and track information."
        if type(fp) == type(""):
            try:
                fp = open(fp)
            except FileError:
                raise ReadException("cannot read", fp)
        if self.track:
            raise ReadException("reading with track nonempty", fp.name, 1)
        if fp.name.endswith(".png") or fp.name.endswith(".jpg"):
            self.filename = fp.name
            return
        if not fp.name.endswith(".trk"):
            raise ReadException("cannot read this filetype", fp.name, 0)
        header = fp.readline().split()
        if header[0] != 'FILE':
            raise ReadException("missing FILE element", fp.name, 1)
        else:
            self.filename = header[1]
        while (i, line) in enumerate(fp):
            fields = line.split()
            if len(fields) != 3:
                raise ReadException("ill-formed line", fp.name, i+1)
            (tag, x, y) = fields
            if tag not in ("JOURNEY", "BATTLE", "REST"):
                raise ReadException("invalid tag field", fp.name, i+1)
            try:
                x = int(x)
                y = int(y)
            except ValuError:
                raise ReadException("invalid coordinate field", fp.name, i+1)
            self.track.append((tag, x, y))
    def __getitem__(self, n):
        return self.track[n]
    def __setitem__(self, n, v):
        self.track[n] = v
    def pop(self):
        self.track.pop()

class ModalFileSelector:
    def __init__(self, default):
        self.default = default
        self.filename = None
        # Create a new file selection widget
        self.filew = gtk.FileSelection("File selection")

        self.filew.connect("destroy", self.destroy)
        # Connect the ok_button to file_selected method
        self.filew.ok_button.connect("clicked", self.file_selected)
    
        # Connect the cancel_button to destroy the widget
        self.filew.cancel_button.connect("clicked",
                                         lambda w: self.filew.destroy())
    
        self.filew.set_filename(self.default)
        self.filew.run()

    def file_selected(self, w):
        self.filename = self.filew.get_filename()

    def destroy(self, widget):
        sys.exit(0)

class TrackEditor:
    def __init__(self, filename=None, verbose=False):
        self.verbose = verbose
        # Initialize our info about the map and track 
        self.journey = JourneyTrack()
        self.journey.read(filename)
        # We need two copies of the map -- one scratchpad for scribbling on,
        # and one for restoring from when we erase track dots.
        self.log("about to read map %s" % self.journey.filename)
        try:
            self.background = gtk.Image()
            self.background.set_from_file(self.journey.filename)
            self.scratchpad = gtk.Image()
            self.scratchpad.set_from_file(self.journey.filename)
        except:
            self.fatal_error("Error while reading background map %s" % self.journey.filename)
        # Now get the icons we'll need for scribbling on the map with.
        try:
            self.journey_image = gtk.Image()
            self.journey_image.set_from_file(journey_icon)
            self.battle_image = gtk.Image()
            self.battle_image.set_from_file(battle_icon)
            self.rest_image = gtk.Image()
            self.rest_image.set_from_file(rest_icon)
        except:
            self.fatal_error("error while reading icons")
        # FIXME: Set up editing window
        self.log("initialization successful")

    def log(self, msg):
        "Notify user of error and die."
        if self.verbose:
            print >>sys.stderr, "trackplacer:", msg

    def fatal_error(self, msg):
        "Notify user of error and die."
        w = gtk.MessageDialog(type=gtk.MESSAGE_ERROR, buttons=gtk.BUTTONS_OK)
        w.set_markup(msg)
        w.run()
        sys.exit(1)

if __name__ == "__main__":
    (options, arguments) = getopt.getopt(sys.argv[1:], "hv?", ['verbose', 'help'])
    verbose = False
    for (opt, val) in options:
        if opt in ('-?', '-h', '--help'):
            print __doc__
            sys.exit(0)
        elif opt in ('-v', '--verbose'):
            verbose=True

    wesnoth.wmltools.pop_to_top("trackplacer")
    if arguments:
        TrackEditor(filename=arguments[0], verbose=verbose)
    else:
        TrackEditor(ModalFileSelector(default_map).filename, verbose=verbose)
