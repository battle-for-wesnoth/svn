#!/usr/bin/env python
#
# macroscope -- generate cross-reference listings of WML macro usage
#
# By Eric S. Raymond April 2007.
# (Yes, this *is* named after an ancient Piers Anthony novel.)

import sys, os, time, re, getopt

def allfiles(dir):
    "Get the names of all files under dir, ignoring .svn directories."
    datafiles = []
    os.chdir(dir)	# So we can deal in relative pathnames.
    os.path.walk(".",
                 lambda arg, dir, names: datafiles.extend(map(lambda x: os.path.normpath(os.path.join(dir,x)), names)),
                 None)
    return filter(lambda x: ".svn" not in x, datafiles)

def initialize(verbose):
    "Prepare for crosschecks."
    # This assumes we're being called from our source-tree location
    datadir = os.path.join(*os.path.split(os.getcwd())[:-1])
    if verbose:
        print "# Data directory is: %s" % datadir

    datafiles = allfiles(datadir)
    #print "Data files: %s" % `datafiles`[1:-1]

    # Get the names of all WML files.
    cfgfiles = filter(lambda x: x.endswith(".cfg"), datafiles)

    # Get the names of all utility-macro definition files
    utilsfiles = filter(lambda x: x.startswith("utils"), cfgfiles) 
    if verbose:
        print "Definition files: %s" % `utilsfiles`[1:-1]

    return (datafiles, cfgfiles, utilsfiles)

class reference:
    "Describes a location by file and line."
    def __init__(self, filename, line=None):
        self.filename = filename
        self.line = line
    def __str__(self):
        if self.line:
            return self.filename + ":" + `self.line`
        else:
            return self.filebame

class macro_cross_reference:
    def __init__(self, fromlist, tolist):
        self.gather_macro_definitions(fromlist)
        self.check_macro_references(tolist)
    def gather_macro_definitions(self, filelist):
        "Collect macro definitions from a specified filelist."
        self.xref = {}
        for filename in filelist:
            dfp = open(filename)
            for (n, line) in enumerate(dfp):
                if line.startswith("#define"):
                    tokens = line.split()
                    name = tokens[1]
                    here = reference(filename, n+1)
                    if name in self.xref:
                        print >>sys.stderr, "*** Warning: duplicate definition of %s from %s, at %s\n" \
                              % (name, self.xref[name][0], here)
                    self.xref[name] = (here, {})
            dfp.close()
        return self.xref
    def check_macro_references(self, filelist):
        "Decorate definitions with all references from a specified filelist."
        self.unresolved = []
        formals = []
        for filename in filelist:
            rfp = open(filename)
            for (n, line) in enumerate(rfp):
                if line.startswith("#define"):
                    formals = line.split()[2:]
                elif line.startswith("#enddef"):
                    formals = []
                if '#' in line:
                    line = line.split('#')[0]
                if not line or "{" not in line:
                    continue
                for match in re.finditer(r"\{([A-Z_][A-Z0-9_:]*[A-Z0-9_])\b", line):
                    name = match.group(1)
                    if name in formals:
                        continue
                    elif name in self.xref:
                        namedict = self.xref[name][1]
                        if filename not in namedict:
                            namedict[filename] = []
                        namedict[filename].append(n+1)
                    else:
                        self.unresolved.append((name, reference(filename,n+1)))
            rfp.close()
    def xrefdump(self, pred=None):
        "Report resolved references."
        for (name, (defloc, references)) in self.xref.items():
            if pred and not pred(name, defloc, references):
                continue
            nrefs = len(references)
            if nrefs == 0:
                print "Macro %s defined at %s is unused" % (name, defloc)
            else:
                print "Macro %s defined at %s is used in %d files:" % (name, defloc, nrefs)
            for (file, linenumbers) in references.items():
                 print "    %s: %s" % (file, `linenumbers`[1:-1])
    def unrefdump(self):
        "Report dangling references."
        if len(self.unresolved) == 0:
            print "# No unresolved references"
        else:
            print "# Dangling references:"
            for (name, reference) in self.unresolved:
                print "%s at %s" % (name, reference)

if __name__ == "__main__":
    print "# Macroscope reporting on %s" % time.ctime() 
    # Process options
    (options, arguments) = getopt.getopt(sys.argv[1:], "mn:N:uv")
    verbose = False
    for (switch, val) in options:
        if (switch == '-m'):
            print "# Checking macro definitions from anywhere"
            print "# against macro references from anywhere."
            print "# Output will list unused macros and undefined references."
            (datafiles, cfgfiles, utilsfiles) = initialize(verbose)
            xref = macro_cross_reference(cfgfiles, cfgfiles)
            print "# Unused macros:"
            xref.xrefdump(lambda n, d, r: len(r) == 0)             
            xref.unrefdump()
            sys.exit(0)
        elif (switch == '-n'):
            print "# Checking macro definitions in the utils directory"
            print "# against macro references from anywhere."
            c = int(val)
            print "# Output reports on util macros used in only %d file(s)."% c
            (datafiles, cfgfiles, utilsfiles) = initialize(verbose)
            xref = macro_cross_reference(utilsfiles, cfgfiles)
            xref.xrefdump(lambda n, d, r: len(r) == c)             
            sys.exit(0)
        elif (switch == '-N'):
            print "# Checking macro definitions anywhere"
            print "# against macro references from anywhere."
            c = int(val)
            print "# Output reports on all macros used in only %d file(s)."% c
            (datafiles, cfgfiles, utilsfiles) = initialize(verbose)
            xref = macro_cross_reference(cfgfiles, cfgfiles)
            xref.xrefdump(lambda n, d, r: len(r) == c)             
            sys.exit(0)
        elif (switch == '-u'):
            print "# Checking macro definitions in the utils directory"
            print "# against macro references from anywhere."
            print "# Output will be a full reference report."
            (datafiles, cfgfiles, utilsfiles) = initialize(verbose)
            xref = macro_cross_reference(utilsfiles, cfgfiles)
            xref.xrefdump()
            sys.exit(0)
        elif (switch == '-u'):
            verbose = True
    # We get here if user didn't pick a valid mode option
    print """
Usage: macroscope [-v] {-m | -n | -N ddd | -u ddd}
    -m     = Report unused macros and undefined references.
    -n ddd = Report on util macros used exactly a specified number of times
    -N ddd = Report on any macros used exactly a specified number of times
    -u     = Full reference report on utils macros
    -v     = set verbose mode, dumping some intermediate results
"""
    sys.exit(1)

